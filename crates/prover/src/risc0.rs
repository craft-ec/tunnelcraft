//! risc0 ZK prover implementation.
//!
//! Uses the risc0 zkVM to generate and verify ZK proofs over batches
//! of ForwardReceipts. The guest program verifies ed25519 signatures,
//! builds a Merkle tree, and commits the root + batch count + sender.

use tracing::{debug, warn};

use risc0_zkvm::{default_prover, ExecutorEnv};
use tunnelcraft_core::ForwardReceipt;
use tunnelcraft_prover_guest_types::{GuestInput, GuestOutput, GuestReceipt};

use crate::traits::{ProofOutput, Prover, ProverError};

// Include the guest ELF binary and image ID generated by risc0_build
include!(concat!(env!("OUT_DIR"), "/methods.rs"));

/// risc0 ZK prover.
///
/// Generates STARK proofs by running the guest program inside the risc0 VM.
/// In dev mode (`RISC0_DEV_MODE=1`), proofs are generated quickly without
/// the full proving pipeline (suitable for testing).
pub struct Risc0Prover;

impl Risc0Prover {
    pub fn new() -> Self {
        Self
    }

    /// Convert a ForwardReceipt to a GuestReceipt for the guest program.
    fn to_guest_receipt(receipt: &ForwardReceipt) -> GuestReceipt {
        let mut signature = [0u8; 64];
        signature.copy_from_slice(&receipt.signature);

        GuestReceipt {
            request_id: receipt.request_id,
            shard_id: receipt.shard_id,
            sender_pubkey: receipt.sender_pubkey,
            receiver_pubkey: receipt.receiver_pubkey,
            blind_token: receipt.blind_token,
            payload_size: receipt.payload_size,
            epoch: receipt.epoch,
            timestamp: receipt.timestamp,
            signature,
        }
    }
}

impl Default for Risc0Prover {
    fn default() -> Self {
        Self::new()
    }
}

impl Prover for Risc0Prover {
    fn prove(&self, batch: &[ForwardReceipt]) -> Result<ProofOutput, ProverError> {
        if batch.is_empty() {
            return Err(ProverError::EmptyBatch);
        }

        let input = GuestInput {
            receipts: batch.iter().map(Self::to_guest_receipt).collect(),
        };

        debug!("Starting risc0 prove for {} receipts", batch.len());

        let env = ExecutorEnv::builder()
            .write(&input)
            .map_err(|e| ProverError::ProofFailed(format!("failed to write guest input: {}", e)))?
            .build()
            .map_err(|e| ProverError::ProofFailed(format!("failed to build executor env: {}", e)))?;

        let receipt = default_prover()
            .prove(env, GUEST_ELF)
            .map_err(|e| ProverError::ProofFailed(format!("risc0 prove failed: {}", e)))?
            .receipt;

        let output: GuestOutput = receipt
            .journal
            .decode()
            .map_err(|e| ProverError::ProofFailed(format!("failed to decode journal: {}", e)))?;

        debug!(
            "risc0 prove complete: root={}, batch_count={}, sender={}",
            hex::encode(&output.root[..8]),
            output.batch_count,
            hex::encode(&output.sender_pubkey[..8]),
        );

        let proof_bytes = bincode::serialize(&receipt)
            .map_err(|e| ProverError::ProofFailed(format!("failed to serialize receipt: {}", e)))?;

        Ok(ProofOutput {
            new_root: output.root,
            proof: proof_bytes,
        })
    }

    fn verify(&self, root: &[u8; 32], proof: &[u8], batch_size: u64) -> Result<bool, ProverError> {
        let receipt: risc0_zkvm::Receipt = bincode::deserialize(proof)
            .map_err(|e| ProverError::VerificationFailed(format!("failed to deserialize receipt: {}", e)))?;

        if let Err(e) = receipt.verify(GUEST_ID) {
            warn!("risc0 verification failed: {}", e);
            return Ok(false);
        }

        let output: GuestOutput = receipt
            .journal
            .decode()
            .map_err(|e| ProverError::VerificationFailed(format!("failed to decode journal: {}", e)))?;

        Ok(output.root == *root && output.batch_count == batch_size)
    }
}
